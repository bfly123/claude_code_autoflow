#!/bin/bash
# cct - Claude Code TriFlow CLI
# Manage TriFlow skill installations across projects

set -euo pipefail
shopt -s nullglob

VERSION="1.0.0"
CCT_HOME="${CCT_HOME:-$HOME/.cct}"
CCT_SOURCE="${CCT_SOURCE:-$HOME/yunwei/claude_triflows}"
CCT_REPO="https://github.com/bfly123/claude-triflow.git"
INSTALLATIONS_FILE="$CCT_HOME/installations"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure CCT_HOME exists
mkdir -p "$CCT_HOME"
touch "$INSTALLATIONS_FILE"

usage() {
    cat << EOF
cct - Claude Code TriFlow CLI v$VERSION

Usage: cct <command> [options]

Commands:
  add .          Install TriFlow to current project
  add all        Install TriFlow to system (~/.claude/commands)
  add <path>     Install TriFlow to specific project

  delete .       Remove TriFlow from current project
  delete all     Remove system installation
  delete <path>  Remove TriFlow from specific project

  update [--local]  Update cct and refresh all installations
  list           Show all installations
  uninstall      Completely remove cct from system

  version        Show version
  help           Show this help

Examples:
  cct add .                  # Install to current project
  cct add all                # Install globally
  cct add ~/myproject        # Install to specific project
  cct delete .               # Remove from current project
  cct update                 # Update from GitHub and refresh all installations
  cct update --local         # Update from local CCT_SOURCE (development)

Config:
  CCT_HOME=$CCT_HOME
  CCT_SOURCE=$CCT_SOURCE
EOF
}

log_info() { printf "${GREEN}[+]${NC} %s\n" "$1"; }
log_warn() { printf "${YELLOW}[!]${NC} %s\n" "$1"; }
log_error() { printf "${RED}[-]${NC} %s\n" "$1"; }
log_blue() { printf "${BLUE}[*]${NC} %s\n" "$1"; }

TRIFLOW_SKILLS=(tr tp dual-design file-op ask-codex review mode-switch docs)
TRIFLOW_COMMANDS=(tr.md tp.md dual-design.md file-op.md ask-codex.md review.md mode-switch.md)

sed_inplace() {
    # Portable in-place edit for GNU sed and BSD/macOS sed.
    # Usage: sed_inplace 's/old/new/' file
    local script="$1"
    local file="$2"
    sed -i.bak "$script" "$file"
    rm -f "${file}.bak"
}

toml_escape_basic() {
    # Escape backslashes and double quotes for TOML basic strings.
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    printf "%s" "$s"
}

update_codex_config() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"

    if [[ ! -f "$codex_cfg" ]]; then
        log_warn "Codex config not found: $codex_cfg (skipping auto-approval setup)"
        return 0
    fi
    if [[ ! -w "$codex_cfg" ]]; then
        log_warn "Codex config not writable: $codex_cfg (skipping auto-approval setup)"
        return 0
    fi

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"

    local tmp
    tmp="$(mktemp "${CCT_HOME}/codex-config.tmp.XXXXXX")"

    if grep -Fq -- "$header" "$codex_cfg"; then
        # Ensure approval_policy = "never" exists within this project section.
        awk -v header="$header" '
            function print_approval() { print "approval_policy = \"never\"" }
            BEGIN { in_section = 0; found = 0 }
            {
                line = $0
                if (line ~ /^\[[^]]+\]$/) {
                    if (in_section == 1) {
                        if (found == 0) print_approval()
                        in_section = 0
                    }
                    if (line == header) {
                        in_section = 1
                        found = 0
                        print line
                        next
                    }
                }
                if (in_section == 1 && line ~ /^[[:space:]]*approval_policy[[:space:]]*=/) {
                    print_approval()
                    found = 1
                    next
                }
                print line
            }
            END {
                if (in_section == 1 && found == 0) print_approval()
            }
        ' "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to update Codex config (parse error): $codex_cfg"; return 0; }
        if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
            rm -f "$tmp"
            log_info "Codex auto-approval ensured (approval_policy=never): $target_path"
        else
            rm -f "$tmp"
            log_warn "Failed to update Codex config (write denied): $codex_cfg"
        fi
        return 0
    fi

    # Append new project config block.
    cat "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to read Codex config: $codex_cfg"; return 0; }
    {
        echo ""
        echo "$header"
        echo "trust_level = \"trusted\""
        echo "approval_policy = \"never\""
        echo "sandbox_mode = \"workspace-write\""
    } >> "$tmp"
    if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
        rm -f "$tmp"
        log_info "Codex auto-approval configured for project: $target_path"
    else
        rm -f "$tmp"
        log_warn "Failed to update Codex config (write denied): $codex_cfg"
    fi
}

canonical_path() {
    # Prefer realpath; fall back to Python for portability.
    local p="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath "$p"
        return 0
    fi
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$p"
}

# Record installation path
record_installation() {
    local path="$1"
    local type="$2"  # project or system
    local install_date="${3:-$(date +%Y-%m-%d)}"
    # Remove existing entry if any
    local tmp
    tmp="$(mktemp "${INSTALLATIONS_FILE}.tmp.XXXXXX")"
    grep -Fv -- "$path|" "$INSTALLATIONS_FILE" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$INSTALLATIONS_FILE"
    # Add new entry with trailing newline
    printf "%s|%s|%s\n" "$path" "$type" "$install_date" >> "$INSTALLATIONS_FILE"
}

# Remove installation record
remove_installation() {
    local path="$1"
    local tmp
    tmp="$(mktemp "${INSTALLATIONS_FILE}.tmp.XXXXXX")"
    grep -Fv -- "$path|" "$INSTALLATIONS_FILE" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$INSTALLATIONS_FILE"
}

# Check source files exist
check_source() {
    if [[ ! -d "$CCT_SOURCE/.claude/skills" ]]; then
        log_error "Skills not found in $CCT_SOURCE/.claude/skills/"
        log_error "Set CCT_SOURCE to your claude_triflows directory"
        exit 1
    fi
    if [[ ! -d "$CCT_SOURCE/.claude/commands" ]]; then
        log_error "Commands not found in $CCT_SOURCE/.claude/commands/"
        exit 1
    fi

    for skill in "${TRIFLOW_SKILLS[@]}"; do
        if [[ ! -d "$CCT_SOURCE/.claude/skills/$skill" ]]; then
            log_error "Missing TriFlow skill in source: $CCT_SOURCE/.claude/skills/$skill"
            exit 1
        fi
    done
}

# Install to a directory
do_install() {
    local target="$1"
    local type="$2"
    local install_date="${3:-}"

    check_source

    # Prevent self-copy when installing into the source repository itself.
    if [[ "$(canonical_path "$target")" == "$(canonical_path "$CCT_SOURCE")" ]]; then
        log_info "Skipping source directory: $target (already up to date)"
        if [[ "$type" == "project" ]]; then
            update_codex_config "$target" || true
        fi
        record_installation "$target" "$type" "${install_date:-}"
        return 0
    fi

    # Copy TriFlow skills directory (only TriFlow-specific subdirs)
    local skills_dir="$target/.claude/skills"
    mkdir -p "$skills_dir"
    for skill in "${TRIFLOW_SKILLS[@]}"; do
        local src="$CCT_SOURCE/.claude/skills/$skill"
        local dst="$skills_dir/$skill"
        rm -rf "$dst" 2>/dev/null || true
        mkdir -p "$dst"
        cp -a "$src/." "$dst/"
    done

    # Copy TriFlow slash command redirects (only TriFlow-specific .md)
    local cmd_dir="$target/.claude/commands"
    mkdir -p "$cmd_dir"
    for cmd in "${TRIFLOW_COMMANDS[@]}"; do
        local src="$CCT_SOURCE/.claude/commands/$cmd"
        if [[ -f "$src" ]]; then
            cp -a "$src" "$cmd_dir/"
        else
            log_warn "Missing command stub in source: $src"
        fi
    done

    # Configure Codex auto-approval for this project installation (TriFlow expects full automation).
    if [[ "$type" == "project" ]]; then
        update_codex_config "$target" || true
    fi

    # Add CLAUDE.md content for project installations
    if [[ "$type" == "project" ]]; then
        local claude_md="$target/CLAUDE.md"
        local triflow_marker="<!-- TRIFLOW -->"

        if [[ ! -f "$claude_md" ]]; then
            # Create new CLAUDE.md with TriFlow section
            cat > "$claude_md" << 'TRIFLOW_EOF'
<!-- TRIFLOW -->
## TriFlow

Task execution workflow. After `/clear`, read:
- `todo.md` - current task and steps
- `state.json` - progress state

Commands: `/tp [requirement]` (plan), `/tr` (run)
<!-- /TRIFLOW -->
TRIFLOW_EOF
            log_info "Created: CLAUDE.md"
        elif ! grep -q "$triflow_marker" "$claude_md"; then
            # Append TriFlow section to existing CLAUDE.md
            cat >> "$claude_md" << 'TRIFLOW_EOF'

<!-- TRIFLOW -->
## TriFlow

Task execution workflow. After `/clear`, read:
- `todo.md` - current task and steps
- `state.json` - progress state

Commands: `/tp [requirement]` (plan), `/tr` (run)
<!-- /TRIFLOW -->
TRIFLOW_EOF
            log_info "Updated: CLAUDE.md (added TriFlow section)"
        fi
    fi

    record_installation "$target" "$type" "${install_date:-}"

    log_info "Installed to: $target/.claude/"
    echo "  - skills/ (tr, tp, dual-design, file-op, mode-switch, review, ask-codex, docs)"
    echo "  - commands/ (slash command redirects)"
}

# Remove from a directory
do_remove() {
    local target="$1"
    local skills_dir="$target/.claude/skills"
    local cmd_dir="$target/.claude/commands"

    local removed_any=false

    # Remove only TriFlow-specific skills
    if [[ -d "$skills_dir" ]]; then
        for skill in "${TRIFLOW_SKILLS[@]}"; do
            if [[ -d "$skills_dir/$skill" ]]; then
                rm -rf "$skills_dir/$skill" 2>/dev/null || true
                removed_any=true
            fi
        done
        rmdir "$skills_dir" 2>/dev/null || true
    fi

    # Remove only TriFlow-specific command stubs
    if [[ -d "$cmd_dir" ]]; then
        for cmd in "${TRIFLOW_COMMANDS[@]}"; do
            if [[ -f "$cmd_dir/$cmd" ]]; then
                rm -f "$cmd_dir/$cmd" 2>/dev/null || true
                removed_any=true
            fi
        done
        # Backward-compat cleanup: older installs may have kept docs under commands/
        if [[ -d "$cmd_dir/docs" ]]; then
            rm -rf "$cmd_dir/docs" 2>/dev/null || true
            removed_any=true
        fi
        rmdir "$cmd_dir" 2>/dev/null || true
    fi

    # Remove empty .claude directory if possible
    rmdir "$target/.claude" 2>/dev/null || true

    if [[ "$removed_any" == true ]]; then
        remove_installation "$target"
        log_info "Removed TriFlow from: $target"

        # Clean TriFlow section from CLAUDE.md
        local claude_md="$target/CLAUDE.md"
        if [[ -f "$claude_md" ]] && grep -q "<!-- TRIFLOW -->" "$claude_md"; then
            # Remove TriFlow section
            sed_inplace '/<!-- TRIFLOW -->/,/<!-- \/TRIFLOW -->/d' "$claude_md"
            # Remove empty CLAUDE.md
            if [[ ! -s "$claude_md" ]] || ! grep -q '[^[:space:]]' "$claude_md"; then
                rm -f "$claude_md"
                log_info "Removed: CLAUDE.md (was empty)"
            else
                log_info "Cleaned: CLAUDE.md (removed TriFlow section)"
            fi
        fi
    else
        log_warn "TriFlow not found in: $target/.claude/"
    fi
}

# Command: add
cmd_add() {
    local target="$1"

    if [[ -z "$target" ]]; then
        log_error "Usage: cct add <.|all|path>"
        exit 1
    fi

    case "$target" in
        ".")
            target="$(pwd)"
            log_blue "Installing to current project: $target"
            do_install "$target" "project"
            ;;
        "all")
            target="$HOME"
            log_blue "Installing to system: ~/.claude/commands"
            do_install "$target" "system"
            ;;
        *)
            # Resolve path
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
            }
            log_blue "Installing to: $target"
            do_install "$target" "project"
            ;;
    esac

    echo ""
    log_info "Done! Use /tp and /tr in Claude Code."
}

# Command: delete
cmd_delete() {
    local target="$1"

    if [[ -z "$target" ]]; then
        log_error "Usage: cct delete <.|all|path>"
        exit 1
    fi

    case "$target" in
        ".")
            target="$(pwd)"
            log_blue "Removing from current project: $target"
            do_remove "$target"
            ;;
        "all")
            target="$HOME"
            log_blue "Removing system installation"
            do_remove "$target"
            ;;
        *)
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
            }
            log_blue "Removing from: $target"
            do_remove "$target"
            ;;
    esac
}

# Command: update
cmd_update() {
    local mode="${1:-}"
    log_blue "Updating cct..."

    if [[ "$mode" != "--local" ]]; then
        log_blue "Fetching latest from GitHub..."
        command -v git >/dev/null 2>&1 || { log_error "git not found (required for 'cct update'; use 'cct update --local' as a fallback)"; exit 1; }

        local repo_dir="$CCT_HOME/repo"
        if [[ -d "$repo_dir/.git" ]]; then
            git -C "$repo_dir" pull --ff-only
        else
            rm -rf "$repo_dir" 2>/dev/null || true
            git clone --depth 1 "$CCT_REPO" "$repo_dir"
        fi

        CCT_SOURCE="$repo_dir"
        local short_hash
        short_hash="$(git -C "$repo_dir" rev-parse --short HEAD 2>/dev/null || true)"
        if [[ -n "${short_hash:-}" ]]; then
            log_info "Updated from GitHub (commit: $short_hash)"
        else
            log_info "Updated from GitHub"
        fi
    fi

    # Update cct itself from source
    if [[ -f "$CCT_SOURCE/cct" ]]; then
        local cct_path="$(which cct 2>/dev/null || echo "$HOME/.local/bin/cct")"
        if [[ -w "$cct_path" ]] || [[ -w "$(dirname "$cct_path")" ]]; then
            if cp "$CCT_SOURCE/cct" "$cct_path" 2>/dev/null; then
                chmod +x "$cct_path" 2>/dev/null || true
                log_info "Updated cct binary: $cct_path"
            else
                log_warn "Cannot update cct binary (copy failed): $cct_path"
            fi
        else
            log_warn "Cannot update cct binary (no write permission)"
        fi
    fi

    # Update all recorded installations
    check_source

    mapfile -t _install_lines < "$INSTALLATIONS_FILE" 2>/dev/null || true

    local count=0
    for line in "${_install_lines[@]}"; do
        [[ -z "${line//[[:space:]]/}" ]] && continue
        IFS='|' read -r path type date <<< "$line"
        [[ -z "${path:-}" ]] && continue
        if [[ -d "$path" ]]; then
            log_blue "Updating: $path"
            do_install "$path" "${type:-project}" "${date:-}"
            ((count+=1))
        else
            log_warn "Skipping (not found): $path"
            remove_installation "$path"
        fi
    done

    echo ""
    log_info "Updated $count installation(s)"
}

# Command: list
cmd_list() {
    log_blue "TriFlow installations:"
    echo ""

    # Check if file has any non-whitespace content
    if ! grep -q '[^[:space:]]' "$INSTALLATIONS_FILE" 2>/dev/null; then
        echo "  (none)"
        return
    fi

    printf "  %-50s %-10s %s\n" "PATH" "TYPE" "DATE"
    printf "  %-50s %-10s %s\n" "----" "----" "----"

    while IFS='|' read -r path type date; do
        [[ -z "$path" ]] && continue
        local status=""
        if [[ -d "$path/.claude/skills" ]]; then
            status="${GREEN}✓${NC}"
        else
            status="${RED}✗${NC}"
        fi
        printf "  %-50s %-10s %s %b\n" "$path" "$type" "$date" "$status"
    done < "$INSTALLATIONS_FILE"
}

# Command: uninstall
cmd_uninstall() {
    log_warn "This will remove cct from your system."
    echo ""
    read -p "Remove all TriFlow installations too? [y/N] " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Remove all installations
        while IFS='|' read -r path type date; do
            [[ -z "$path" ]] && continue
            if [[ -d "$path" ]]; then
                do_remove "$path"
            fi
        done < "$INSTALLATIONS_FILE"
    fi

    # Remove cct binary
    local cct_path="$(which cct 2>/dev/null)"
    if [[ -n "$cct_path" ]] && [[ -f "$cct_path" ]]; then
        rm -f "$cct_path"
        log_info "Removed: $cct_path"
    fi

    # Remove cct config
    rm -rf "$CCT_HOME"
    log_info "Removed: $CCT_HOME"

    echo ""
    log_info "cct uninstalled. Goodbye!"
}

# Main
case "${1:-}" in
    add)
        cmd_add "$2"
        ;;
    delete|remove|rm)
        cmd_delete "$2"
        ;;
    update|upgrade)
        cmd_update "${2:-}"
        ;;
    list|ls)
        cmd_list
        ;;
    uninstall)
        cmd_uninstall
        ;;
    version|-v|--version)
        echo "cct v$VERSION"
        ;;
    help|-h|--help|"")
        usage
        ;;
    *)
        log_error "Unknown command: $1"
        echo "Run 'cct help' for usage."
        exit 1
        ;;
esac
