#!/bin/bash
# cca - Claude Code AutoFlow CLI
# Manage AutoFlow skill installations across projects

set -euo pipefail
shopt -s nullglob

VERSION="1.0.0"
GIT_COMMIT=""
GIT_DATE=""

CCA_HOME="${CCA_HOME:-${XDG_CONFIG_HOME:-$HOME/.config}/cca}"
CCA_CACHE="${CCA_CACHE:-${XDG_CACHE_HOME:-$HOME/.cache}/cca}"
CCA_INSTALL_PREFIX="${CCA_INSTALL_PREFIX:-$HOME/.local/share/cca}"
CCA_BIN_DIR="${CCA_BIN_DIR:-$HOME/.local/bin}"

CCA_REPO_GIT="https://github.com/bfly123/claude_code_autoflow.git"
CCA_REPO_URL="${CCA_REPO_GIT%.git}"
CCA_REPO_API="https://api.github.com/repos/bfly123/claude_code_autoflow/commits/main"
INSTALLATIONS_FILE="$CCA_HOME/installations"

resolve_script_path() {
    local src="$1"
    while [[ -L "$src" ]]; do
        local dir
        dir="$(cd -P "$(dirname "$src")" && pwd)"
        src="$(readlink "$src")"
        [[ "$src" != /* ]] && src="$dir/$src"
    done
    local dir
    dir="$(cd -P "$(dirname "$src")" && pwd)"
    echo "$dir/$(basename "$src")"
}

CCA_SCRIPT_PATH="$(resolve_script_path "${BASH_SOURCE[0]}")"
CCA_SCRIPT_ROOT="$(cd "$(dirname "$CCA_SCRIPT_PATH")" && pwd)"

# Default source path:
# - env CCA_SOURCE (if set)
# - resolved script directory (symlink-aware)
CCA_SOURCE="${CCA_SOURCE:-$CCA_SCRIPT_ROOT}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure CCA_HOME and cache exist
mkdir -p "$CCA_HOME" "$CCA_CACHE"
touch "$INSTALLATIONS_FILE"

usage() {
    cat << EOF
cca - Claude Code AutoFlow CLI v$VERSION

Usage: cca <command> [options]

Commands:
  add .          Configure Codex permissions for current project
  add <path>     Configure Codex permissions for a project

  delete .       Remove Codex permissions config for current project
  delete <path>  Remove Codex permissions config for a project

  update [--local]  Update cca and refresh ~/.claude/
  list           Show configured projects
  uninstall      Remove cca from system

  version        Show version and commit info
  help           Show this help

Examples:
  cca add .                  # Configure current project
  cca add ~/myproject        # Configure a project
  cca delete .               # Remove config from current project
  cca update                 # Update cca and refresh ~/.claude/
  cca update --local         # Refresh ~/.claude/ from current CCA_SOURCE

Config:
  CCA_HOME=$CCA_HOME
  CCA_INSTALL_PREFIX=$CCA_INSTALL_PREFIX
  CCA_SOURCE=$CCA_SOURCE
EOF
}

log_info() { printf "${GREEN}[+]${NC} %s\n" "$1"; }
log_warn() { printf "${YELLOW}[!]${NC} %s\n" "$1"; }
log_error() { printf "${RED}[-]${NC} %s\n" "$1"; }
log_blue() { printf "${BLUE}[*]${NC} %s\n" "$1"; }

AUTOFLOW_SKILLS=(tr tp dual-design file-op ask-codex review mode-switch docs)
AUTOFLOW_COMMANDS=(tr.md tp.md dual-design.md file-op.md ask-codex.md review.md mode-switch.md auto.md)

detect_platform() {
    local name
    name="$(uname -s 2>/dev/null || echo unknown)"
    case "$name" in
        Linux) echo "linux" ;;
        Darwin) echo "macos" ;;
        *) echo "unknown" ;;
    esac
}

require_platform() {
    local p
    p="$(detect_platform)"
    if [[ "$p" != "linux" && "$p" != "macos" ]]; then
        log_error "Unsupported platform: $(uname -s 2>/dev/null || echo unknown) (Linux/macOS only)"
        exit 1
    fi
}

sed_inplace() {
    # Portable in-place edit for GNU sed and BSD/macOS sed.
    # Usage: sed_inplace 's/old/new/' file
    local script="$1"
    local file="$2"
    sed -i.bak "$script" "$file"
    rm -f "${file}.bak"
}

toml_escape_basic() {
    # Escape backslashes and double quotes for TOML basic strings.
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    printf "%s" "$s"
}

update_codex_config() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"

    if [[ ! -f "$codex_cfg" ]]; then
        log_warn "Codex config not found: $codex_cfg (skipping auto-approval setup)"
        return 0
    fi
    if [[ ! -w "$codex_cfg" ]]; then
        log_warn "Codex config not writable: $codex_cfg (skipping auto-approval setup)"
        return 0
    fi

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"

    local tmp
    tmp="$(mktemp "${CCA_HOME}/codex-config.tmp.XXXXXX")"

    if grep -Fq -- "$header" "$codex_cfg"; then
        # Ensure approval_policy = "never" exists within this project section.
        awk -v header="$header" '
            function print_approval() { print "approval_policy = \"never\"" }
            BEGIN { in_section = 0; found = 0 }
            {
                line = $0
                if (line ~ /^\[[^]]+\]$/) {
                    if (in_section == 1) {
                        if (found == 0) print_approval()
                        in_section = 0
                    }
                    if (line == header) {
                        in_section = 1
                        found = 0
                        print line
                        next
                    }
                }
                if (in_section == 1 && line ~ /^[[:space:]]*approval_policy[[:space:]]*=/) {
                    print_approval()
                    found = 1
                    next
                }
                print line
            }
            END {
                if (in_section == 1 && found == 0) print_approval()
            }
        ' "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to update Codex config (parse error): $codex_cfg"; return 0; }
        if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
            rm -f "$tmp"
            log_info "Codex auto-approval ensured (approval_policy=never): $target_path"
        else
            rm -f "$tmp"
            log_warn "Failed to update Codex config (write denied): $codex_cfg"
        fi
        return 0
    fi

    # Append new project config block.
    cat "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to read Codex config: $codex_cfg"; return 0; }
    {
        echo ""
        echo "$header"
        echo "trust_level = \"trusted\""
        echo "approval_policy = \"never\""
        echo "sandbox_mode = \"full-auto\""
    } >> "$tmp"
    if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
        rm -f "$tmp"
        log_info "Codex auto-approval configured for project: $target_path"
    else
        rm -f "$tmp"
        log_warn "Failed to update Codex config (write denied): $codex_cfg"
    fi
}

remove_codex_config() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"

    if [[ ! -f "$codex_cfg" ]]; then
        log_warn "Codex config not found: $codex_cfg (skipping removal)"
        return 0
    fi
    if [[ ! -w "$codex_cfg" ]]; then
        log_warn "Codex config not writable: $codex_cfg (skipping removal)"
        return 0
    fi

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"

    if ! grep -Fq -- "$header" "$codex_cfg" 2>/dev/null; then
        log_warn "Codex project config not found (already removed): $target_path"
        return 0
    fi

    local tmp
    tmp="$(mktemp "${CCA_HOME}/codex-config.tmp.XXXXXX")"

    awk -v header="$header" '
        BEGIN { skip = 0 }
        {
            line = $0
            if (line ~ /^\[[^]]+\]$/) {
                if (skip == 1) skip = 0
                if (line == header) { skip = 1; next }
            }
            if (skip == 1) next
            print line
        }
    ' "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to update Codex config (parse error): $codex_cfg"; return 0; }

    if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
        rm -f "$tmp"
        log_info "Codex project config removed: $target_path"
    else
        rm -f "$tmp"
        log_warn "Failed to update Codex config (write denied): $codex_cfg"
    fi
}

codex_project_configured() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"
    [[ -f "$codex_cfg" ]] || return 1

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"
    grep -Fq -- "$header" "$codex_cfg" 2>/dev/null
}

canonical_path() {
    # Prefer realpath; fall back to Python for portability.
    local p="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath "$p"
        return 0
    fi
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$p"
}

system_install_dir() {
    if [[ -d "$CCA_INSTALL_PREFIX" && -f "$CCA_INSTALL_PREFIX/cca" && -f "$CCA_INSTALL_PREFIX/install.sh" ]]; then
        echo "$CCA_INSTALL_PREFIX"
        return 0
    fi
    return 1
}

get_local_version_info() {
    local dir="$1"
    local commit="$GIT_COMMIT"
    local date="$GIT_DATE"

    if [[ -z "${commit:-}" ]] && command -v git >/dev/null 2>&1 && [[ -d "$dir/.git" ]]; then
        commit="$(git -C "$dir" log -1 --format='%h' 2>/dev/null || true)"
        date="$(git -C "$dir" log -1 --format='%cs' 2>/dev/null || true)"
    fi

    printf "%s|%s\n" "${commit:-}" "${date:-}"
}

get_remote_version_info() {
    command -v curl >/dev/null 2>&1 || return 1
    local api_response commit date
    api_response="$(curl -fsSL "$CCA_REPO_API" 2>/dev/null || true)"
    [[ -n "$api_response" ]] || return 1

    commit="$(echo "$api_response" | grep -o '"sha": "[^"]*"' | head -1 | cut -d'"' -f4 | cut -c1-7)"
    date="$(echo "$api_response" | grep -o '"date": "[^"]*"' | head -1 | cut -d'"' -f4 | cut -c1-10)"
    [[ -n "${commit:-}" ]] || return 1
    printf "%s|%s\n" "${commit:-}" "${date:-}"
}

# Record installation path
record_installation() {
    local path="$1"
    local type="$2"  # project or system
    local install_date="${3:-$(date +%Y-%m-%d)}"
    # Remove existing entry if any
    local tmp
    tmp="$(mktemp "${INSTALLATIONS_FILE}.tmp.XXXXXX")"
    grep -Fv -- "$path|" "$INSTALLATIONS_FILE" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$INSTALLATIONS_FILE"
    # Add new entry with trailing newline
    printf "%s|%s|%s\n" "$path" "$type" "$install_date" >> "$INSTALLATIONS_FILE"
}

# Remove installation record
remove_installation() {
    local path="$1"
    local tmp
    tmp="$(mktemp "${INSTALLATIONS_FILE}.tmp.XXXXXX")"
    grep -Fv -- "$path|" "$INSTALLATIONS_FILE" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$INSTALLATIONS_FILE"
}

# Check source files exist (for refreshing ~/.claude/)
check_source_dir() {
    local source_root="${1:-$CCA_SOURCE}"
    if [[ ! -d "$source_root/claude_source/skills" ]]; then
        log_error "Skills not found in $source_root/claude_source/skills/"
        log_error "Set CCA_SOURCE to your AutoFlow repository directory"
        exit 1
    fi
    if [[ ! -d "$source_root/claude_source/commands" ]]; then
        log_error "Commands not found in $source_root/claude_source/commands/"
        exit 1
    fi

    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        if [[ ! -d "$source_root/claude_source/skills/$skill" ]]; then
            log_error "Missing AutoFlow skill in source: $source_root/claude_source/skills/$skill"
            exit 1
        fi
    done
}

install_global_skills() {
    local source_root="$1"
    check_source_dir "$source_root"

    local target="$HOME/.claude"
    mkdir -p "$target/skills" "$target/commands"

    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        rm -rf "$target/skills/$skill" 2>/dev/null || true
        cp -a "$source_root/claude_source/skills/$skill" "$target/skills/"
    done

    for cmd in "${AUTOFLOW_COMMANDS[@]}"; do
        cp -a "$source_root/claude_source/commands/$cmd" "$target/commands/"
    done

    log_info "Installed skills/commands to ~/.claude/ (globally visible)"
}

# Command: version
cmd_version() {
    local install_dir=""
    if install_dir="$(system_install_dir 2>/dev/null)"; then
        :
    else
        install_dir="$CCA_SOURCE"
    fi

    local commit date
    IFS='|' read -r commit date <<< "$(get_local_version_info "$install_dir")"

    local extra=""
    [[ -n "${commit:-}" ]] && extra="$commit"
    [[ -n "${date:-}" ]] && extra="${extra:+$extra }$date"

    echo "cca v$VERSION${extra:+ $extra}"
    echo "Install/source: $install_dir"

    local remote_commit remote_date
    local remote
    if remote="$(get_remote_version_info 2>/dev/null)"; then
        IFS='|' read -r remote_commit remote_date <<< "$remote"
        if [[ -n "${commit:-}" && -n "${remote_commit:-}" ]]; then
            if [[ "$commit" == "$remote_commit" ]]; then
                echo "Status: up to date"
            else
                echo "Status: update available (${remote_commit}${remote_date:+ $remote_date})"
                echo "Run: cca update"
            fi
        else
            echo "Status: unable to compare versions"
        fi
    else
        echo "Status: unable to check updates (network/curl unavailable)"
    fi
}

# Install to a directory
do_install() {
    local target="$1"
    local type="${2:-project}"
    local install_date="${3:-}"

    [[ "$type" == "project" ]] || type="project"
    update_codex_config "$target" || true

    record_installation "$target" "$type" "${install_date:-}"
    log_info "Configured Codex permissions: $target"
}

# Remove from a directory
do_remove() {
    local target="$1"
    remove_codex_config "$target" || true
    remove_installation "$target"
    log_info "Removed Codex permissions config: $target"
}

# Command: add
cmd_add() {
    local target="$1"

    if [[ -z "$target" ]]; then
        log_error "Usage: cca add <.|path>"
        exit 1
    fi

    case "$target" in
        ".")
            target="$(pwd)"
            log_blue "Configuring current project: $target"
            do_install "$target" "project"
            ;;
        *)
            # Resolve path
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
            }
            log_blue "Configuring: $target"
            do_install "$target" "project"
            ;;
    esac

    echo ""
    log_info "Done! AutoFlow is available globally in ~/.claude/ (run ./install.sh install if needed)."
}

# Command: delete
cmd_delete() {
    local target="$1"

    if [[ -z "$target" ]]; then
        log_error "Usage: cca delete <.|path>"
        exit 1
    fi

    case "$target" in
        ".")
            target="$(pwd)"
            log_blue "Removing config from current project: $target"
            do_remove "$target"
            ;;
        *)
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
            }
            log_blue "Removing config from: $target"
            do_remove "$target"
            ;;
    esac
}

# Command: update
cmd_update() {
    local mode="${1:-}"
    require_platform
    local source_root=""

    if [[ "$mode" == "--local" ]]; then
        source_root="$CCA_SOURCE"
        log_blue "Refreshing ~/.claude/ from local source: $source_root"
    else
        local install_dir
        if ! install_dir="$(system_install_dir)"; then
            log_error "System installation not found: $CCA_INSTALL_PREFIX"
            log_error "Run: ./install.sh install"
            exit 1
        fi

        log_blue "Updating system installation: $install_dir"

        if command -v git >/dev/null 2>&1 && [[ -d "$install_dir/.git" ]]; then
            log_blue "Updating via git pull..."
            git -C "$install_dir" pull --ff-only
        else
            log_blue "Updating via tarball..."
            (
                set -euo pipefail
                command -v tar >/dev/null 2>&1 || { log_error "tar not found"; exit 1; }

                tmp_dir="$(mktemp -d 2>/dev/null || mktemp -d -t cca_update.XXXXXX)"
                trap 'rm -rf "$tmp_dir"' EXIT

                tarball_url="$CCA_REPO_URL/archive/refs/heads/main.tar.gz"
                tarball_path="$tmp_dir/main.tar.gz"

                if command -v curl >/dev/null 2>&1; then
                    curl -fsSL -o "$tarball_path" "$tarball_url"
                elif command -v wget >/dev/null 2>&1; then
                    wget -q -O "$tarball_path" "$tarball_url"
                else
                    log_error "Missing dependency: curl or wget"
                    exit 1
                fi

                tar -xzf "$tarball_path" -C "$tmp_dir"

                extracted_dir="$tmp_dir/claude_code_autoflow-main"
                if [[ ! -d "$extracted_dir" ]]; then
                    extracted_dir="$(find "$tmp_dir" -maxdepth 1 -type d -name '*-main' -print -quit 2>/dev/null || true)"
                fi
                [[ -d "$extracted_dir" ]] || { log_error "Failed to extract tarball"; exit 1; }

                remote_commit=""
                remote_date=""
                remote="$(get_remote_version_info 2>/dev/null || true)"
                if [[ -n "${remote:-}" ]]; then
                    IFS='|' read -r remote_commit remote_date <<< "$remote"
                fi

                detected_bin_dir="$CCA_BIN_DIR"
                detected_bin_dir="$(dirname "$(command -v cca 2>/dev/null || echo "$CCA_BIN_DIR/cca")")"

                CCA_INSTALL_PREFIX="$install_dir" \
                    CCA_BIN_DIR="$detected_bin_dir" \
                    CCA_GIT_COMMIT="${remote_commit:-}" \
                    CCA_GIT_DATE="${remote_date:-}" \
                    bash "$extracted_dir/install.sh" install
            )
        fi

        CCA_SOURCE="$install_dir"
        source_root="$install_dir"
        log_info "Updated system installation"
    fi

    # Refresh globally visible skills/commands in ~/.claude/
    install_global_skills "$source_root"

    mapfile -t _install_lines < "$INSTALLATIONS_FILE" 2>/dev/null || true

    local count=0
    for line in "${_install_lines[@]}"; do
        [[ -z "${line//[[:space:]]/}" ]] && continue
        IFS='|' read -r path type date <<< "$line"
        [[ -z "${path:-}" ]] && continue
        if [[ -d "$path" ]]; then
            log_blue "Refreshing Codex config: $path"
            do_install "$path" "${type:-project}" "${date:-}"
            ((count+=1))
        else
            log_warn "Skipping (not found): $path"
            remove_installation "$path"
        fi
    done

    echo ""
    log_info "Updated $count project(s)"
}

# Command: list
cmd_list() {
    log_blue "Configured projects:"
    echo ""

    # Check if file has any non-whitespace content
    if ! grep -q '[^[:space:]]' "$INSTALLATIONS_FILE" 2>/dev/null; then
        echo "  (none)"
        return
    fi

    printf "  %-50s %-10s %s\n" "PATH" "TYPE" "DATE"
    printf "  %-50s %-10s %s\n" "----" "----" "----"

    while IFS='|' read -r path type date; do
        [[ -z "$path" ]] && continue
        local status=""
        if codex_project_configured "$path"; then
            status="${GREEN}✓${NC}"
        else
            status="${RED}✗${NC}"
        fi
        printf "  %-50s %-10s %s %b\n" "$path" "$type" "$date" "$status"
    done < "$INSTALLATIONS_FILE"
}

# Command: uninstall
cmd_uninstall() {
    log_warn "This will remove cca from your system."
    echo ""
    read -p "Remove all configured project entries from Codex config too? [y/N] " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Remove all configured projects (best effort).
        mapfile -t _install_lines < "$INSTALLATIONS_FILE" 2>/dev/null || true
        for line in "${_install_lines[@]}"; do
            [[ -z "${line//[[:space:]]/}" ]] && continue
            IFS='|' read -r path type date <<< "$line"
            [[ -z "${path:-}" ]] && continue
            do_remove "$path" || true
        done
    fi

    # Remove cca binary
    local cca_path="$(which cca 2>/dev/null)"
    if [[ -n "$cca_path" ]] && [[ -f "$cca_path" ]]; then
        rm -f "$cca_path"
        log_info "Removed: $cca_path"
    fi

    # Remove system install copy
    local install_dir=""
    if install_dir="$(system_install_dir 2>/dev/null)"; then
        rm -rf "$install_dir" 2>/dev/null || true
        log_info "Removed: $install_dir"
    fi

    # Remove cca config
    rm -rf "$CCA_HOME"
    log_info "Removed: $CCA_HOME"

    echo ""
    log_info "cca uninstalled. Goodbye!"
}

# Main
case "${1:-}" in
    add)
        cmd_add "$2"
        ;;
    delete|remove|rm)
        cmd_delete "$2"
        ;;
    update|upgrade)
        cmd_update "${2:-}"
        ;;
    list|ls)
        cmd_list
        ;;
    uninstall)
        cmd_uninstall
        ;;
    version|-v|--version)
        cmd_version
        ;;
    help|-h|--help|"")
        usage
        ;;
    *)
        log_error "Unknown command: $1"
        echo "Run 'cca help' for usage."
        exit 1
        ;;
esac
